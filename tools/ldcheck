#!/bin/bash
# List needed shared libraries and their paths for an Android lib

# Initialize variables
FILE=""
LIB_PATHS="system/lib:system/lib64:vendor/lib:vendor/lib64"

# Parse command-line options
while getopts "d:" opt; do
  case $opt in
    d) FILE="$OPTARG" ;;
    *) echo "Usage: $0 [-d file]" >&2
       exit 1 ;;
  esac
done

if [ -z "$FILE" ]; then
  echo "Error: No file specified." >&2
  echo "Usage: $0 [-d file]" >&2
  exit 1
fi

# Ensure the file exists
if [ ! -f "$FILE" ]; then
  echo "Error: File '$FILE' not found." >&2
  exit 1
fi

# Determine architecture suffix
ARCH=$(file "$FILE" | grep -o '32-bit\|64-bit')
if [[ "$ARCH" == "32-bit" ]]; then
  ARCH_SUFFIX=""
else
  ARCH_SUFFIX="64"
fi

# Split LIB_PATHS into an array
IFS=':' read -r -a PATH_ARRAY <<< "$LIB_PATHS"

echo "Needed shared libraries and their paths:"

# Get the list of needed shared libraries into an array
NEEDED_LIBS=()
while IFS= read -r lib; do
  NEEDED_LIBS+=("$lib")
done < <(readelf -d "$FILE" 2>/dev/null | grep '\(NEEDED\)' | sed -r 's/.*\[(.*)\]/\1/')

# Initialize an associative array to track found libraries and their paths
declare -A FOUND_LIBS_DIRS

# Now iterate over NEEDED_LIBS
for lib in "${NEEDED_LIBS[@]}"; do
  LIB_FOUND=false
  for DIR in "${PATH_ARRAY[@]}"; do
    LIB_PATH="$DIR/$lib"
    if [ -f "$LIB_PATH" ]; then
      echo "$lib -> $LIB_PATH"
      LIB_FOUND=true
      # Record the directory where the library was found
      FOUND_LIBS_DIRS["$DIR"]=1
      break
    fi
  done
  if [ "$LIB_FOUND" = false ]; then
    # Suggest the most likely path based on known ones
    if [[ "$lib" =~ ^libQSEE || "$lib" =~ ^libdrmfs ]]; then
      SUGGESTED_PATH="vendor/lib$ARCH_SUFFIX/$lib"
    else
      # Default to system lib path
      SUGGESTED_PATH="system/lib$ARCH_SUFFIX/$lib"
    fi
    echo "$lib -> Not found in standard library paths"
    echo "Suggested location: $SUGGESTED_PATH"
  fi
done
